# 🔍 算法识别UI设计方案

## 一、UI布局

```
┌─────────────────────────────────────────────────────────────┐
│  菜单栏：文件 | 编辑 | 分析 | 视图 | 帮助                    │
├─────────────┬───────────────────────────┬───────────────────┤
│             │                           │                   │
│  函数列表   │      代码面板             │   算法分析面板    │
│             │                           │   (新增)          │
│  [functions]│  📥 0x1000 | ldr r0, [r1] │                   │
│             │  ⚡ 0x1004 | eor r0, r2   │  ┌─────────────┐ │
│             │  📤 0x1008 | str r0, [r3] │  │ 循环检测    │ │
│             │  ➕ 0x100c | add r4, #1   │  ├─────────────┤ │
│             │  🔀 0x1010 | blt #0x1000  │  │ 加密识别    │ │
│             │                           │  ├─────────────┤ │
├─────────────┼───────────────────────────┤  │ 模式匹配    │ │
│             │                           │  ├─────────────┤ │
│  寄存器面板 │    污点追踪面板           │  │ 代码生成    │ │
│             │                           │  └─────────────┘ │
└─────────────┴───────────────────────────┴───────────────────┘
```

## 二、"算法分析"面板详细设计

### Tab 1: 🔁 循环检测

```
┌─────────────────────────────────────────────┐
│ 🔁 循环检测                     [自动检测]  │
├─────────────────────────────────────────────┤
│                                             │
│ 检测到 3 个循环：                           │
│                                             │
│ ┌─────────────────────────────────────────┐│
│ │ 📌 循环 #1                        ✅    ││
│ │ ────────────────────────────────────── ││
│ │ 起始地址: 0x12025000                   ││
│ │ 结束地址: 0x12025014                   ││
│ │ 循环次数: 16 次                        ││
│ │ 循环变量: r4 (0→15)                    ││
│ │ 循环体大小: 5 条指令                   ││
│ │                                        ││
│ │ 循环体代码：                           ││
│ │   📥 ldr r0, [r1, r4]                 ││
│ │   📥 ldr r2, [r5]                     ││
│ │   ⚡ eor r0, r0, r2                   ││
│ │   📤 str r0, [r3, r4]                 ││
│ │   ➕ add r4, r4, #1                   ││
│ │                                        ││
│ │ [查看详情] [跳转到循环] [生成伪代码]   ││
│ └─────────────────────────────────────────┘│
│                                             │
│ ┌─────────────────────────────────────────┐│
│ │ 📌 循环 #2                        ⚠️    ││
│ │ ────────────────────────────────────── ││
│ │ 起始地址: 0x12026000                   ││
│ │ 结束地址: 0x12026024                   ││
│ │ 循环次数: 64 次                        ││
│ │ 类型: 嵌套循环                         ││
│ │                                        ││
│ │ [查看详情] [跳转到循环]                ││
│ └─────────────────────────────────────────┘│
│                                             │
└─────────────────────────────────────────────┘
```

### Tab 2: 🔐 加密识别

```
┌─────────────────────────────────────────────┐
│ 🔐 加密算法识别              [开始分析]     │
├─────────────────────────────────────────────┤
│                                             │
│ 检测到 2 个可能的加密算法：                 │
│                                             │
│ ┌─────────────────────────────────────────┐│
│ │ ⚡ XOR加密                    置信度: 95%││
│ │ ────────────────────────────────────── ││
│ │ 位置: 循环 #1 (0x12025000)             ││
│ │ 特征:                                  ││
│ │   ✅ 检测到 eor 指令                   ││
│ │   ✅ 固定密钥寄存器 r2 (0x0A)          ││
│ │   ✅ 循环处理 16 字节                  ││
│ │   ✅ 输入缓冲区: [r1]                  ││
│ │   ✅ 输出缓冲区: [r3]                  ││
│ │                                        ││
│ │ 伪代码:                                ││
│ │   for (i=0; i<16; i++) {              ││
│ │     output[i] = input[i] ^ 0x0A;      ││
│ │   }                                   ││
│ │                                        ││
│ │ [导出C代码] [导出Python] [Frida Hook] ││
│ └─────────────────────────────────────────┘│
│                                             │
│ ┌─────────────────────────────────────────┐│
│ │ 🔒 疑似MD5                   置信度: 60%││
│ │ ────────────────────────────────────── ││
│ │ 位置: 循环 #2 (0x12026000)             ││
│ │ 特征:                                  ││
│ │   ✅ 64 轮循环                         ││
│ │   ⚠️ 检测到常量 0x67452301             ││
│ │   ⚠️ 大量位运算                        ││
│ │   ❌ 未检测到完整S-box                 ││
│ │                                        ││
│ │ 置信度较低，可能需要人工确认            ││
│ │                                        ││
│ │ [查看详情] [标记为MD5] [标记为误报]    ││
│ └─────────────────────────────────────────┘│
│                                             │
└─────────────────────────────────────────────┘
```

### Tab 3: 🧩 模式匹配

```
┌─────────────────────────────────────────────┐
│ 🧩 指令模式匹配                             │
├─────────────────────────────────────────────┤
│                                             │
│ 搜索模式: [load-xor-store         ] [搜索] │
│                                             │
│ 预设模式:                                   │
│  • load-xor-store (XOR加密)                │
│  • load-add-store (简单加密)               │
│  • load-shift-xor-store (混合加密)         │
│  • table-lookup (查表操作)                 │
│  • rotate-xor (旋转异或)                   │
│                                             │
│ 匹配结果 (3处):                            │
│                                             │
│  1. 0x12025000 - 0x12025014                │
│     📥 ldr → ⚡ eor → 📤 str                │
│     [查看] [追踪]                          │
│                                             │
│  2. 0x12025100 - 0x12025114                │
│     📥 ldr → ⚡ eor → 📤 str                │
│     [查看] [追踪]                          │
│                                             │
│  3. 0x12025200 - 0x12025214                │
│     📥 ldr → ⚡ eor → 📤 str                │
│     [查看] [追踪]                          │
│                                             │
└─────────────────────────────────────────────┘
```

### Tab 4: 📝 代码生成

```
┌─────────────────────────────────────────────┐
│ 📝 代码生成                                 │
├─────────────────────────────────────────────┤
│                                             │
│ 基于: 循环 #1 (XOR加密)                     │
│                                             │
│ 语言: [C ▼] [Python] [JavaScript] [Frida]  │
│                                             │
│ ┌─────────────────────────────────────────┐│
│ │ // C代码                                ││
│ │ void xor_encrypt(                       ││
│ │     uint8_t *input,                     ││
│ │     uint8_t *output,                    ││
│ │     int length                          ││
│ │ ) {                                     ││
│ │     uint8_t key = 0x0A;                 ││
│ │     for (int i = 0; i < length; i++) { ││
│ │         output[i] = input[i] ^ key;    ││
│ │     }                                   ││
│ │ }                                       ││
│ │                                         ││
│ │ // 调用示例                             ││
│ │ uint8_t input[16] = {...};             ││
│ │ uint8_t output[16];                    ││
│ │ xor_encrypt(input, output, 16);        ││
│ └─────────────────────────────────────────┘│
│                                             │
│ [复制代码] [保存为文件] [导出所有格式]      │
│                                             │
└─────────────────────────────────────────────┘
```

## 三、代码面板集成

在代码面板中，检测到的循环和算法会被**高亮标注**：

```
━━━━━━━━━━ 🔁 循环 #1 开始 (16次) ━━━━━━━━━━
📥 0x12025000 | ldr r0, [r1, r4]  <-- 循环变量 r4
⚡ 0x12025004 | eor r0, r0, r2    <-- XOR操作
📤 0x12025008 | str r0, [r3, r4]
➕ 0x1202500c | add r4, r4, #1    <-- 递增
🔀 0x12025010 | cmp r4, #0x10
🔀 0x12025014 | blt #0x12025000   <-- 跳回
━━━━━━━━━━ 🔁 循环 #1 结束 ━━━━━━━━━━━━━━

⚡ 检测到: XOR加密 (置信度: 95%)
   [查看详情] [生成代码] [导出]
```

## 四、右键菜单增强

在代码行上**右键**增加选项：

```
┌─────────────────────────┐
│ 复制                    │
│ 跳转到地址              │
│ ──────────────────────  │
│ 反向追踪寄存器值来源    │
│ 正向污点追踪            │
│ ──────────────────────  │
│ ▶ 标记为循环开始        │ 🆕
│ ▶ 标记为循环结束        │ 🆕
│ ▶ 分析算法模式          │ 🆕
│ ▶ 生成伪代码            │ 🆕
└─────────────────────────┘
```

## 五、菜单栏新增

```
┌─────────────────────────────────────────────┐
│ 文件 | 编辑 | 分析 | 视图 | 帮助           │
│             ▼                               │
│       ┌─────────────────────┐              │
│       │ 🔁 检测循环结构     │              │
│       │ 🔐 识别加密算法     │              │
│       │ 🧩 搜索指令模式     │              │
│       │ ───────────────────  │              │
│       │ 📝 生成C代码        │              │
│       │ 📝 生成Python代码   │              │
│       │ 📝 生成Frida脚本    │              │
│       └─────────────────────┘              │
└─────────────────────────────────────────────┘
```

## 六、通知栏

在底部状态栏显示分析进度：

```
┌─────────────────────────────────────────────┐
│ 就绪 | 正在分析循环结构... ████████░░ 80%   │
└─────────────────────────────────────────────┘
```

完成后显示：

```
┌─────────────────────────────────────────────┐
│ ✅ 分析完成：检测到 3 个循环，2 个加密算法  │
└─────────────────────────────────────────────┘
```

## 七、实现优先级

### 🟢 第一阶段（容易）
1. **循环检测**：识别简单循环
2. **XOR加密识别**：识别XOR模式
3. **代码生成**：生成C/Python伪代码

### 🟡 第二阶段（中等）
4. **模式匹配**：用户自定义指令模式
5. **嵌套循环**：识别多层循环
6. **置信度评分**：给出识别准确度

### 🔴 第三阶段（困难）
7. **AES/DES识别**：识别复杂加密
8. **MD5/SHA识别**：识别哈希算法
9. **Frida脚本生成**：自动生成Hook代码

## 八、技术实现要点

### 1. 循环检测算法

```python
class LoopDetector:
    def detect(self, events):
        loops = []
        branch_stack = []  # 用于处理嵌套
        
        for i, event in enumerate(events):
            if self.is_backward_branch(event):
                target_pc = self.get_branch_target(event)
                loop_start = self.find_event_by_pc(target_pc, events)
                
                if loop_start:
                    loop = {
                        'start_idx': loop_start,
                        'end_idx': i,
                        'start_pc': events[loop_start].pc,
                        'end_pc': event.pc,
                        'count': self.count_iterations(loop_start, i, events),
                        'variable': self.find_loop_variable(loop_start, i, events),
                        'body': events[loop_start:i+1]
                    }
                    loops.append(loop)
        
        return loops
    
    def find_loop_variable(self, start, end, events):
        # 查找递增的寄存器（如 r4: 0→1→2→...）
        candidates = {}
        for event in events[start:end]:
            for reg, val in event.writes.items():
                if reg not in candidates:
                    candidates[reg] = []
                candidates[reg].append(val)
        
        # 找到单调递增的寄存器
        for reg, values in candidates.items():
            if self.is_monotonic_increasing(values):
                return reg
        return None
```

### 2. XOR加密识别

```python
class CipherDetector:
    def detect_xor(self, loop_body):
        features = {
            'has_xor': False,
            'has_load': False,
            'has_store': False,
            'key_register': None,
            'key_value': None
        }
        
        for event in loop_body:
            if 'eor' in event.asm or 'xor' in event.asm:
                features['has_xor'] = True
                # 查找固定密钥寄存器
                for reg in event.reads:
                    if self.is_constant(reg, loop_body):
                        features['key_register'] = reg
                        features['key_value'] = self.get_constant_value(reg, loop_body)
            
            if 'ldr' in event.asm:
                features['has_load'] = True
            
            if 'str' in event.asm:
                features['has_store'] = True
        
        # 判断是否为XOR加密
        if all([features['has_xor'], features['has_load'], features['has_store']]):
            confidence = 0.95 if features['key_register'] else 0.7
            return {
                'type': 'XOR',
                'confidence': confidence,
                **features
            }
        
        return None
```

### 3. 伪代码生成

```python
class CodeGenerator:
    def generate_c_code(self, loop_info, cipher_info):
        if cipher_info['type'] == 'XOR':
            template = '''
void xor_cipher(uint8_t *input, uint8_t *output, int length) {{
    uint8_t key = {key};
    for (int i = 0; i < length; i++) {{
        output[i] = input[i] ^ key;
    }}
}}
'''
            return template.format(key=hex(cipher_info['key_value']))
    
    def generate_python_code(self, loop_info, cipher_info):
        if cipher_info['type'] == 'XOR':
            template = '''
def xor_cipher(data, key):
    return bytes([b ^ key for b in data])

# 使用示例
result = xor_cipher(input_data, {key})
'''
            return template.format(key=hex(cipher_info['key_value']))
```

## 九、用户体验优化

### 1. 渐进式发现
- 用户无需手动触发，后台自动分析
- 分析结果逐步显示（先循环，再加密）

### 2. 可视化反馈
- 代码面板中用颜色块标注循环范围
- 动画效果展示循环执行过程

### 3. 交互式探索
- 点击循环 → 自动跳转到代码位置
- 悬停显示详细信息
- 支持手动修正识别结果

### 4. 导出友好
- 一键导出所有检测结果
- 支持多种格式（JSON, Markdown, HTML）
- 集成到污点分析报告

## 十、总结

### ✅ 易于实现
- 循环检测（向后跳转）
- XOR加密识别（固定模式）
- C/Python伪代码生成

### ⚠️ 中等难度
- 嵌套循环
- 模式匹配引擎
- 置信度评分

### ❌ 较难实现
- AES/MD5等复杂算法
- 混淆代码识别
- 完整Frida脚本生成

**建议**：先实现第一阶段，验证可行性后再扩展。

