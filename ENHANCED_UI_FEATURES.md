# 🎨 增强界面功能说明

## ✨ 阶段1改进：增强代码面板（已完成）

### 核心改进

#### 1. **行号显示** ✅
- 在代码编辑器左侧显示行号
- 方便快速定位和跳转
- 支持大量代码行的显示

#### 2. **内联寄存器值和内存数据** ✅
```
之前（旧版本）：
0x1234: ldr r0, [r1, #0x10]

现在（增强版本）：
0042 | 📥 0x1234 | ldr r0, [r1, #0x10] | r0=0x4A3B←[0x7FFE10] (r1=0x7FFE00)
```

**显示内容**：
- **行号**：`0042` - 事件在trace中的序号
- **操作图标**：`📥` - 标识操作类型（加载/存储/运算等）
- **PC地址**：`0x1234` - 当前指令地址
- **汇编指令**：`ldr r0, [r1, #0x10]` - 完整汇编
- **关键信息**：
  - `r0=0x4A3B` - 写入寄存器的值
  - `←[0x7FFE10]` - 从内存地址加载
  - `(r1=0x7FFE00)` - 读取的寄存器值

#### 3. **操作类型图标和颜色标注** ✅

| 操作类型 | 图标 | 颜色 | 说明 |
|---------|------|------|------|
| 内存加载 | 📥 | 🟢 绿色 | ldr, ldm, pop 等 |
| 内存存储 | 📤 | 🔵 蓝色 | str, stm, push 等 |
| 算术运算 | ➕ | 🟡 黄色 | add, sub, mul 等 |
| 逻辑运算 | ⚡ | 🟠 橙色 | and, or, eor, xor 等 |
| 移位操作 | ↔️ | 🟣 紫色 | lsl, lsr, asr, ror 等 |
| 分支跳转 | 🔀 | 🔴 红色 | b, bl, beq, bne 等 |
| 比较指令 | ⚖️ | ⚪ 灰色 | cmp, cmn, tst 等 |
| 数据移动 | ➡️ | 🔷 青色 | mov, movw, movt 等 |

**好处**：
- 🎯 **快速识别关键操作**：一眼看出哪些是加密运算（XOR/EOR）
- 🔍 **追踪数据流向**：通过颜色快速找到数据加载和存储
- 🚀 **提升分析效率**：减少阅读时间，专注于逻辑分析

#### 4. **鼠标悬停提示（Tooltip）** ✅

当鼠标悬停在代码行上时，显示详细信息：

```
行号: 0042
PC: 0x12025abc
指令: ldr r0, [r1, #0x10]
类型: 📥 load
读取: r1=0x7FFE00
写入: r0
内存: 0x7FFE10 (load)
时间: 12345678
```

**包含信息**：
- ✅ 行号和PC地址
- ✅ 完整指令
- ✅ 操作类型
- ✅ 读取的寄存器和值
- ✅ 写入的寄存器
- ✅ 内存访问地址和类型
- ✅ 时间戳

### 使用场景

#### 场景1：追踪XOR加密

**旧版本**：
```
0x1234: ldr r0, [r1]
0x1238: ldr r2, [r5]
0x123c: eor r0, r0, r2
0x1240: str r0, [r3]
```
❌ 看不出数据值，需要频繁切换到寄存器面板

**增强版本**：
```
0042 | 📥 0x1234 | ldr r0, [r1]     | r0=0x48←[0x7FFE00] (r1=0x7FFE00)
0043 | 📥 0x1238 | ldr r2, [r5]     | r2=0x0A←[0x8000] (r5=0x8000)
0044 | ⚡ 0x123c | eor r0, r0, r2   | r0=0x42 (r0=0x48, r2=0x0A)
0045 | 📤 0x1240 | str r0, [r3]     | →[0x8100] (r0=0x42, r3=0x8100)
```
✅ 一眼看出：`0x48 XOR 0x0A = 0x42`，这是XOR加密！

#### 场景2：追踪循环索引

**增强版本**：
```
0100 | 📥 0x1000 | ldr r0, [r1, r4]  | r0=0x41←[0x7000] (r1=0x7000, r4=0x00)
0101 | ⚡ 0x1004 | eor r0, r0, r2    | r0=0x4B (r0=0x41, r2=0x0A)
0102 | 📤 0x1008 | str r0, [r3, r4]  | →[0x8000] (r0=0x4B, r3=0x8000, r4=0x00)
0103 | ➕ 0x100c | add r4, r4, #1    | r4=0x01 (r4=0x00)
0104 | 🔀 0x1010 | cmp r4, #0x10     | (r4=0x01)
0105 | 🔀 0x1014 | blt #0x1000       | 
---
0106 | 📥 0x1000 | ldr r0, [r1, r4]  | r0=0x42←[0x7001] (r1=0x7000, r4=0x01)
0107 | ⚡ 0x1004 | eor r0, r0, r2    | r0=0x48 (r0=0x42, r2=0x0A)
```
✅ 清晰看出：循环变量`r4`从`0→1→...`，处理16字节数据

#### 场景3：还原算法逻辑

通过颜色和图标，快速识别算法结构：

```
📥 加载输入     [r1] → r0
📥 加载密钥     [r5] → r2
⚡ XOR运算      r0 XOR r2 → r0
📤 存储输出     r0 → [r3]
➕ 索引递增     r4 + 1 → r4
🔀 循环判断     r4 < 16 ? 跳转
```

伪代码：
```c
for (int i = 0; i < 16; i++) {
    uint8_t input = buf_in[i];   // 📥
    uint8_t key = key_buf[i];    // 📥
    uint8_t output = input ^ key; // ⚡
    buf_out[i] = output;         // 📤
}
```

### 性能优化

为避免UI卡顿，实施了以下优化：

1. **延迟加载**：只获取当前行附近±5行的寄存器值
2. **悬停时获取**：其他行的详细信息在鼠标悬停时才加载
3. **寄存器缓存**：利用TraceParser的LRU缓存，避免重复计算

### 技术实现

#### 核心类

1. **`InstructionAnalyzer`**：指令分析器
   - 识别操作类型
   - 提供图标和颜色
   - 提取内存访问信息

2. **`EnhancedCodeFormatter`**：代码格式化器
   - 生成增强显示格式
   - 内联寄存器值
   - 添加内存数据提示

3. **`EnhancedCodeEdit`**：增强代码编辑器
   - 带行号显示
   - 支持悬停提示
   - 可点击地址跳转

4. **`EnhancedAssemblyHighlighter`**：增强语法高亮
   - 根据操作类型着色
   - 高亮寄存器、地址、立即数
   - 美化显示效果

## ✨ 阶段2改进：智能寄存器面板（已完成）

### 核心功能

#### 1. **自动推断寄存器用途** ✅
寄存器面板新增两列："用途"和"趋势"

**用途识别**：
- 📍 **指针**：值在内存地址范围（如`0x7FFE00`）
- 📏 **索引**：递增且值较小（如`0→1→2→...`）
- 🔢 **计数器**：递增的大值
- 🔑 **密钥/常量**：始终不变的值
- 📦 **数据**：频繁变化的值
- 📐 **长度**：小值且变化不大
- ↗️ **偏移**：相对小的值
- 📝 **临时**：其他情况

**识别逻辑**：
```python
# 示例：r1 始终是 0x7FFE00 → 识别为"指针"
# 示例：r4 从 0→1→2→...→15 → 识别为"索引"
# 示例：r2 始终是 0x0A → 识别为"密钥"
```

#### 2. **变化趋势分析** ✅

| 趋势 | 图标 | 颜色 | 说明 |
|------|------|------|------|
| 常量 | → | ⚪ 灰色 | 值不变 |
| 递增 | ↗ | 🟢 绿色 | 值持续增加 |
| 递减 | ↘ | 🔴 红色 | 值持续减少 |
| 频繁变化 | ↕ | 🟠 橙色 | 值经常改变 |
| 周期性 | ⟳ | 🟣 紫色 | 值重复出现 |

#### 3. **人性化命名建议** ✅
```
寄存器 | 之前      | 之后      | 用途      | 趋势
-------|----------|----------|-----------|------
r0     | 0x48     | 0x42     | 📦 data0  | ↕
r1     | 0x7FFE00 | 0x7FFE00 | 📍 ptr1   | →
r2     | 0x0A     | 0x0A     | 🔑 key2   | →
r3     | 0x8000   | 0x8000   | 📍 ptr3   | →
r4     | 0x00     | 0x01     | 📏 idx4   | ↗
```

**使用场景**：
- 快速识别循环变量（📏 idx + ↗）
- 快速识别指针（📍 ptr + →）
- 快速识别密钥（🔑 key + →）

#### 4. **悬停详情** ✅
鼠标悬停在"用途"或"趋势"上时显示：
```
指针 | 不变 | 0x7FFE00→0x7FFE00
```

### 性能优化
- 只分析前10个寄存器（避免性能问题）
- 分析范围：当前事件前后各50行
- 结果缓存：相同范围不重复分析

## ✨ 阶段3改进：内存查看器（已完成）

### 核心功能

#### 1. **内存查看面板** ✅
新增右侧停靠面板：内存查看器

**功能**：
- 📍 **地址输入**：输入要查看的内存地址
- 📏 **长度设置**：16-4096字节可调
- 🔍 **查看按钮**：立即查看内存
- ⚖️ **对比模式**：显示执行前后差异

#### 2. **十六进制+ASCII视图** ✅
```
偏移    +0 +1 +2 +3 +4 +5 +6 +7  +8 +9 +A +B +C +D +E +F  ASCII
0000: 48 65 6C 6C 6F 20 57 6F  72 6C 64 00 00 00 00 00  Hello World.....
0010: 4A 3B 5E 09 12 34 00 00  00 00 00 00 00 00 00 00  J;^..4..........
```

#### 3. **执行前后对比** ✅
```
【执行前】
0000: 48 65 6C 6C 6F 20 57 6F  72 6C 64 00 00 00 00 00  Hello World.....

【执行后】
0000: 4A 3B 5E 09 12 34 00 00  00 00 00 00 00 00 00 00  J;^..4..........
      ^^^^^^^^^^^^^^^^^^^ 变化的字节（高亮显示）

【变化详情】
  0x0000: 0x48 → 0x4A
  0x0001: 0x65 → 0x3B
  0x0002: 0x6C → 0x5E
  ...
  
变化统计: 5 字节变化 (31.3%)
```

#### 4. **辅助功能** ✅
- **自动识别缓冲区类型**：text/binary/encrypted/unknown
- **变化高亮**：红色标注变化的字节
- **统计信息**：显示变化字节数和变化率

### 使用方法

1. **从代码面板查看内存**：
   - 找到内存读写指令（如`ldr r0, [r1]`）
   - 查看内联信息：`r0=0x48←[0x7FFE00]`
   - 在内存查看器输入地址`0x7FFE00`并点击查看

2. **对比模式**：
   - 勾选"对比模式"复选框
   - 自动显示执行前后的内存差异

### ⚠️ 重要说明

**Unidbg trace文件的限制**：
- ❌ **不包含实际内存数据**
- ✅ 只包含寄存器的值和指令执行记录

因此内存查看器功能**默认隐藏**，因为trace文件中没有可用的内存数据。

**如何查看内存相关信息**：
1. 通过寄存器值推断内存地址（如 `sp=0xe4fff728`）
2. 使用污点追踪查看数据流向
3. 查看内存读写指令的寄存器值（间接了解内存操作）

**未来可能的改进**：
- 如果trace格式扩展支持内存数据记录
- 或者集成外部内存dump文件

### 阶段4：算法还原助手（待实施）
- 自动检测循环结构
- 识别加密算法（XOR/AES/MD5等）
- 生成伪代码（C/Python）
- 导出Frida Hook脚本

### 阶段5：数据流可视化（待实施）
- 图形化展示值传播路径
- 汇合点高亮
- 交互式探索

## 🎓 使用建议

### 快速上手

1. **加载trace文件**：菜单 → 文件 → 打开
2. **选择函数**：左侧函数列表点击
3. **查看代码**：中间代码面板自动显示增强格式
4. **悬停查看详情**：鼠标悬停在代码行上
5. **点击跳转**：点击地址可跳转

### 最佳实践

1. **寻找加密算法**：
   - 关注 ⚡ 橙色（XOR/EOR）
   - 关注 🔀 红色（循环跳转）
   - 查看操作数值是否有规律

2. **追踪数据来源**：
   - 找到关键值（如加密结果）
   - 查看 `r0=0x42` 这样的写入
   - 反向追踪：右键 → 反向追踪寄存器值来源

3. **还原算法**：
   - 识别循环结构（blt/bne跳回）
   - 记录关键操作（加载→运算→存储）
   - 绘制数据流图
   - 编写伪代码

## 📚 API文档

### `InstructionAnalyzer`

```python
# 获取操作类型
op_type = InstructionAnalyzer.get_operation_type("ldr r0, [r1]")
# 返回: 'load'

# 获取图标
icon = InstructionAnalyzer.get_operation_icon('load')
# 返回: '📥'

# 获取颜色
color = InstructionAnalyzer.get_operation_color('load')
# 返回: '#4ade80'
```

### `EnhancedCodeFormatter`

```python
formatter = EnhancedCodeFormatter(parser)

# 格式化单个事件
line = formatter.format_event(event, event_index, regs_before, regs_after)
# 返回: "0042 | 📥 0x1234 | ldr r0, [r1] | r0=0x4A3B←[0x7FFE10]"

# 格式化多个事件
text = formatter.format_events(events, start_index, parser)
```

## 🐛 已知问题

1. ~~行号区域宽度固定~~ ✅ 已修复：自动计算宽度
2. ~~获取寄存器值可能导致UI卡顿~~ ✅ 已优化：延迟加载
3. ~~悬停提示位置可能偏移~~ ✅ 已优化：使用Qt内置tooltip

## 🙏 反馈与建议

如有问题或建议，欢迎通过以下方式反馈：
- GitHub Issues
- 邮件联系
- Pull Request

---

**版本**: v1.0  
**日期**: 2025-11-17  
**状态**: 阶段1已完成，阶段2-5待实施

