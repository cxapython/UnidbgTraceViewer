# 污点分析功能对比说明

## 🎯 核心概念澄清

你的项目有**两种污点分析**，它们追踪的方向**相反**：

### 1. 反向追踪（Backward Taint）- 追踪值的来源

```
目标: 追踪某个值是怎么来的
方向: 往前看（向上追溯）
      
示例:
  [100] mov r1, r0      ← 来源2: r0 给 r1
  [50]  mov r0, #4      ← 来源1: 立即数
  ====== 从这里开始反向追踪 ======
  [200] mov r3, r1      ← 目标: r1=4 是怎么来的？

结果: r1=4 的来源链
  事件200: mov r3, r1    (使用 r1=4)
  事件100: mov r1, r0    (r0 传给 r1)
  事件50:  mov r0, #4    (源头: 立即数4)
```

**用途**:
- ✅ 追踪某个寄存器值的计算过程
- ✅ 理解某个结果是怎么算出来的
- ✅ 逆向分析算法逻辑

### 2. 前向追踪（Forward Taint）- 追踪值的传播

```
目标: 追踪某个值传播到哪里去了
方向: 往后看（向下传播）

示例:
  ====== 从这里开始前向追踪 ======
  [100] ldr r0, [r5]    ← 污点源: r0 被标记为污点
  [200] add r1, r0, #1  ← 传播1: r0污染 → r1污染
  [300] mov r2, r1      ← 传播2: r1污染 → r2污染
  [400] str r2, [r3]    ← 传播3: r2污染 → 内存污染

结果: r0 的污点传播到:
  事件100: ldr r0, [r5]  (污点源)
  事件200: add r1, r0, #1 (r0 → r1)
  事件300: mov r2, r1     (r1 → r2)
  事件400: str r2, [r3]   (r2 → 内存)
```

**用途**:
- ✅ 追踪敏感数据(密钥/输入)流向哪里
- ✅ 检测数据泄露
- ✅ 理解输入如何影响输出

---

## 📋 当前实现状态

### ✅ 已实现 - 反向追踪 (Backward)

**文件**: `trace_parser.py` 的 `taint_backward()` 方法

**逻辑**:
```python
def taint_backward(self, start_idx, target_reg, target_value):
    """
    从 start_idx 往前找，追踪 target_reg=target_value 是怎么来的
    
    传播规则:
    1. 找到写入 target_reg 的指令
    2. 检查读取的源寄存器
    3. 继续向前追踪源寄存器
    4. 直到遇到立即数/常量/函数调用边界
    """
```

**示例代码**:
```python
# 从事件1000反向追踪 r1=0x8 的来源
hits = parser.taint_backward(start_idx=1000, target_reg='r1', target_value=0x8)

# 结果（按时间正序）:
# [50]  movs r1, #4      源头: 立即数
# [100] add r2, r1, #1   使用 r1
# [200] mov r3, r1       使用 r1
```

### ✅ 已实现 - 前向追踪 (Forward) - 原版

**文件**: `trace_parser.py` 的 `taint_forward()` 方法

**逻辑**:
```python
def taint_forward(self, start_idx, source_regs, source_mem_addrs):
    """
    从 start_idx 往后找，追踪污点如何传播
    
    传播规则:
    1. 标记源寄存器/内存为污点
    2. 算术运算: 如果读取污点 → 写入也污染
    3. ldr: 如果内存污染 → 寄存器污染
    4. str: 如果寄存器污染 → 内存污染
    5. 立即数覆盖 → 清洗污点
    """
```

**示例代码**:
```python
# 从事件0开始，追踪 r0 传播到哪里
hits = parser.taint_forward(
    start_idx=0, 
    source_regs=['r0'],
    enable_memory_taint=True
)

# 结果:
# [0]   ldr r0, [r5]     污点源
# [100] add r1, r0, #1   r0污染 → r1污染
# [200] mov r2, r1       r1污染 → r2污染
# [300] str r2, [r3]     r2污染 → 内存污染
```

### 🆕 新增 - 增强前向追踪 (Enhanced Forward)

**文件**: `enhanced_taint.py` + `value_flow.py`

**改进点**:
1. **字节级内存污点** - 精确到每个字节
2. **污点标签系统** - 记录每个污点的来源
3. **汇合点检测** - 自动找到多个污点合并的位置
4. **传播策略** - STRICT/NORMAL/LOOSE 可配置
5. **隐式流检测** - 处理条件分支的污点影响

**示例代码**:
```python
from trace_viewer.enhanced_taint import EnhancedTaintAnalyzer

analyzer = EnhancedTaintAnalyzer()
analyzer.add_source('reg', 'r0', 0)
analyzer.add_source('reg', 'r1', 0)

# 分析后...
# 查看污点来源
sources = analyzer.get_taint_sources('r5')
# 结果: [('reg', 'r0', 0), ('reg', 'r1', 0)]

# 查看汇合点（多个污点合并）
confluence = analyzer.get_confluence_points()
# {300: [[('reg', 'r0'), ('reg', 'r1')]]}
# ↑ 事件300是关键计算点，r0和r1的污点在这里合并
```

---

## 🔍 你的问题：当前逻辑是什么？

**你现在有的**:

1. **反向追踪** (`taint_backward`): 
   - ✅ 追踪某个值是怎么来的（往前看）
   - ✅ 完全符合你的描述

2. **前向追踪** (`taint_forward`): 
   - ✅ 追踪某个值传播到哪里（往后看）
   - ❌ 不是追踪"怎么来的"，而是追踪"去哪了"

3. **增强前向追踪** (刚添加的):
   - ✅ 增强版的前向传播
   - ✅ 额外提供: 污点来源标签、汇合点检测
   - ❌ 还是前向传播，不是反向溯源

---

## 💡 使用建议

### 场景1: 想知道某个值是怎么来的

**用反向追踪**:
```python
# GUI操作:
1. 找到目标指令（如 mov r3, r1）
2. 右键 → "反向追踪寄存器值来源"
3. 输入: 寄存器=r1, 值=0x8
4. 查看结果（往前的传播链）

# 代码:
hits = parser.taint_backward(start_idx=1000, target_reg='r1', target_value=0x8)
```

### 场景2: 想知道某个输入影响了哪些地方

**用前向追踪**:
```python
# GUI操作:
1. 找到输入点（如 ldr r0, [r5]）
2. 右键 → "值流追踪" → "污点前向分析"
3. 输入: 源寄存器=r0
4. 查看结果（往后的传播链）

# 代码:
hits = parser.taint_forward(start_idx=0, source_regs=['r0'])
```

### 场景3: 追踪多个输入，找它们如何合并计算

**用增强前向追踪**:
```python
# GUI操作:
1. 找到输入点
2. 勾选"增强模式"
3. 勾选"显示汇合点"
4. 输入: 源寄存器=r0,r1
5. 查看结果，汇合点会高亮显示 ⭐

# 代码:
analyzer = EnhancedTaintAnalyzer()
analyzer.add_source('reg', 'r0', 0)
analyzer.add_source('reg', 'r1', 0)
# ... 分析
confluence = analyzer.get_confluence_points()  # 找关键计算点
```

---

## 📊 功能对比表

| 功能 | 反向追踪 | 前向追踪(原版) | 增强前向追踪 |
|------|---------|--------------|-------------|
| **方向** | 往前看 ⬆️ | 往后看 ⬇️ | 往后看 ⬇️ |
| **目的** | 追踪来源 | 追踪传播 | 追踪传播+分析 |
| **污点粒度** | 值级别 | 地址级别 | 字节级别 ✨ |
| **来源追踪** | ✅ | ❌ | ✅ 标签系统 |
| **汇合点检测** | ❌ | ❌ | ✅ |
| **隐式流** | ❌ | 部分 | ✅ 可配置 |
| **UI支持** | ✅ | ✅ | ✅ 新增 |
| **适用场景** | 理解算法 | 数据流分析 | 深度分析 |

---

## 🎯 总结

**你的理解是对的！**

- **反向追踪** = 追踪某个值是怎么来的（往前看）✅
- **前向追踪** = 追踪某个值传播到哪里（往后看）✅

**两者是互补的**:
- 想知道"怎么来"用反向
- 想知道"去哪了"用前向
- 想深度分析用增强前向

**实际应用**:
```
逆向分析加密算法:
1. 用前向追踪: 追踪密钥从哪来 → 找到读取位置
2. 用增强前向: 追踪密钥传播 → 找到加密计算点（汇合点）
3. 用反向追踪: 从加密结果反推 → 理解计算过程
```

你的项目现在**三个功能都有了**，可以全方位分析 trace！🎉

